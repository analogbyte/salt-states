import salt.key
import salt.output

import gnupg
import smtplib
from email.utils import formatdate
import subprocess
import os
import pwd
import grp
import crypt

def _generate(minion_id):
    p = subprocess.Popen('pwgen -s 40 -N 1', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    pwclear = p.stdout.read().strip()
    pwhash = crypt.crypt(pwclear, "$6$%s" % os.urandom(8).encode('base_64').strip())
    with open("/srv/pillar/%s_root_password.sls" % minion_id, "w") as sls:
        sls.write('root_password: ' + pwhash)
    salt.output.display_output('%s: Done.' % minion_id, '', __opts__)
    salt.output.display_output('Run state.sls set_rootpw to push this to the minion.', '', __opts__)
    _save_password(minion_id, pwclear)

def _save_password(minion_id, password):
    config = __opts__.get('mail')
    from_addr = config.get('from')
    to_addrs = config.get('to')
    host = config.get('host')
    port = config.get('port')
    user = config.get('username')
    passwd = config.get('password')
    subject = 'root password for %s' % minion_id
    gpgowner = config.get('gpgowner')
    salt.output.display_output('%s: Sending encrypted password to: %s.' % (minion_id, to_addrs), '', __opts__)

    gpg = gnupg.GPG(gnupghome=os.path.expanduser('~%s/.gnupg' % gpgowner), options=['--trust-model always'])
    encrypted_data = gpg.encrypt(password, to_addrs)
    if not encrypted_data.ok:
        salt.output.display_output('%s: Encryption failed, no password was sent. You have to reset the password using Salt.' % minion_id, '', __opts__)
        content = 'Encryption failed, no password was sent.\r\n\r\n%s\r\n%s' % ( encrypted_data.status, encrypted_data.stderr )
    else:
        content = str(encrypted_data)
    message = ('From: {0}\r\n'
               'To: {1}\r\n'
               'Date: {2}\r\n'
               'Subject: {3}\r\n'
               '\r\n'
               '{4}').format(from_addr,
                             to_addrs,
                             formatdate(localtime=True),
                             subject,
                             content)
    server = smtplib.SMTP(host, int(port))
    server.starttls()
    server.login(user, passwd)
    server.sendmail(from_addr, to_addrs, message)
    server.quit()
    return encrypted_data.ok

def gen(minion_id):
    '''
    Generates a file within this masters pillar tree, named
    minionid_root_password.sls, containing a pillar entry root_password with a
    random password hash.

    CLI Example:

    .. code-block:: bash

        salt-run root_password.gen minionid
    '''
    if not os.path.isfile("/srv/pillar/%s_root_password.sls" % minion_id):
        return _generate(minion_id)
    else:
        salt.output.display_output('%s: A password generated by this module already exists.' % minion_id, '', __opts__)
        return False

def regen(minion_id):
    '''
    Same as gen, but overrites an existing file.

    CLI Example:

    .. code-block:: bash

        salt-run root_password.regen minionid
    '''
    return _generate(minion_id)

def regen_all():
    '''
    Refreshes root passwords on all minions.

    CLI Example:

    .. code-block:: bash

        salt-run root_password.regen_all
    '''
    success = True
    opts = salt.config.master_config('/etc/salt/master')
    keys = salt.key.Key(opts)
    minions = keys.list_keys().get('minions')
    for minion_id in minions:
        success = success if _generate(minion_id) else False
    salt.output.display_output('\nRoot password regeneration for all minions complete.', '', __opts__)
    return success
